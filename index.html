<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PSI Tribute - Second Reality Interference Effect</title>
    
    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="icon" type="image/x-icon" href="icons/favicon.ico">
    <link rel="manifest" href="site.webmanifest">
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="PSI Tribute - Second Reality Interference Effect">
    <meta name="description" content="A tribute to PSI's iconic interference effect from Future Crew's Second Reality demo (1993). Recreated in JavaScript using AI analysis of the original assembly code.">
    <meta name="keywords" content="Second Reality, Future Crew, PSI, interference effect, demoscene, JavaScript, HTML5 Canvas, KOEA.ASM, tribute">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://stanchak.github.io/PSI/">
    <meta property="og:title" content="PSI Tribute - Second Reality Interference Effect">
    <meta property="og:description" content="A tribute to PSI's iconic interference effect from Future Crew's Second Reality demo (1993).">
    <meta property="og:image" content="https://stanchak.github.io/PSI/psi.jpg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://stanchak.github.io/PSI/">
    <meta property="twitter:title" content="PSI Tribute - Second Reality Interference Effect">
    <meta property="twitter:description" content="A tribute to PSI's iconic interference effect from Future Crew's Second Reality demo (1993).">
    <meta property="twitter:image" content="https://stanchak.github.io/PSI/psi.jpg">

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        /* Ensure canvas fills the screen */
        #myCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        /* Style for the control panel */
        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(5px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            box-sizing: border-box;
        }
        .control-group {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px;
            margin: 5px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            width: calc(100% - 20px);
            max-width: 95%;
            box-sizing: border-box;
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
        }
        .control-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .control-row:last-child {
            margin-bottom: 0;
        }
        .control-label {
            width: 90px;
            font-size: 12px;
            margin-right: 10px;
        }
        input[type="range"] {
            flex-grow: 1;
            height: 16px; /* Increased height for mobile */
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px; /* Increased size for mobile */
            height: 24px; /* Increased size for mobile */
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
        }
        input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }
        .value-display {
            min-width: 45px;
            font-size: 12px;
            text-align: right;
            margin-left: 10px;
        }
        #toggleControls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 15px; /* Larger touch target */
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            font-size: 14px;
        }
        .color-preview {
            display: flex;
            padding: 5px;
            margin-top: 5px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.3);
        }
        .color-box {
            height: 20px;
            flex-grow: 1;
            margin: 0 1px;
        }
        #stats {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 5;
        }
        
        /* Media queries for responsive design */
        /* Audio-related styles */
        .audio-mapping-select {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px;
            border-radius: 4px;
            flex-grow: 1;
            font-size: 14px;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
        }
        
        .audio-levels {
            gap: 2px;
        }
        
        @media (min-width: 768px) {
            #controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: space-around;
                padding: 15px;
                max-height: 60vh;
            }
            .control-group {
                width: auto;
                min-width: 280px;
                max-width: 350px;
                margin: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <div id="stats"></div>
    <div id="controls" style="display: none;">
        <div class="control-group">
            <h3>Wave Properties</h3>
            <div class="control-row">
                <div class="control-label">Wave Speed</div>
                <input type="range" id="waveSpeed" min="0" max="0.2" step="0.01" value="0.05">
                <div class="value-display" id="waveSpeedValue">0.05</div>
            </div>
            <div class="control-row">
                <div class="control-label">Center Speed</div>
                <input type="range" id="centerMovementSpeed" min="0" max="0.1" step="0.001" value="0.02">
                <div class="value-display" id="centerMovementSpeedValue">0.02</div>
            </div>
            <div class="control-row">
                <div class="control-label">Variability</div>
                <input type="range" id="variability" min="0" max="1" step="0.01" value="0.1">
                <div class="value-display" id="variabilityValue">0.1</div>
            </div>
            <div class="control-row">
                <div class="control-label">Wavelength</div>
                <input type="range" id="baseWavelength" min="1" max="100" step="1" value="10">
                <div class="value-display" id="baseWavelengthValue">10</div>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Color Controls</h3>
            <div class="control-row">
                <div class="control-label">Start Color</div>
                <input type="range" id="startColor" min="0" max="359" step="1" value="225">
                <div class="value-display" id="startColorValue">225</div>
            </div>
            <div class="control-row">
                <div class="control-label">End Color</div>
                <input type="range" id="endColor" min="0" max="359" step="1" value="285">
                <div class="value-display" id="endColorValue">285</div>
            </div>
            <div class="control-row">
                <div class="control-label">Cycle Speed</div>
                <input type="range" id="colorCycleSpeed" min="0" max="50" step="1" value="10">
                <div class="value-display" id="colorCycleSpeedValue">10</div>
            </div>
            <div class="control-row">
                <div class="control-label">Color Spread</div>
                <input type="range" id="colorSpread" min="0.1" max="10" step="0.1" value="1">
                <div class="value-display" id="colorSpreadValue">1</div>
            </div>
            <div class="control-row">
                <input type="checkbox" id="lockColorRange" checked>
                <label for="lockColorRange">Lock Color Range</label>
            </div>
            <div id="colorPreview" class="color-preview"></div>
        </div>
        
        <div class="control-group">
            <h3>Render Settings</h3>
            <div class="control-row">
                <div class="control-label">Resolution</div>
                <input type="range" id="resolution" min="0.25" max="1" step="0.05" value="0.5">
                <div class="value-display" id="resolutionValue">0.5x</div>
            </div>
            <div class="control-row">
                <div class="control-label">Centers</div>
                <input type="range" id="numCenters" min="1" max="5" step="1" value="3">
                <div class="value-display" id="numCentersValue">3</div>
            </div>
            <div class="control-row">
                <input type="checkbox" id="showStats" checked>
                <label for="showStats">Show Stats</label>
            </div>
            <div class="control-row">
                <button id="resetBtn" style="padding: 10px; margin-top: 5px; width: 100%; font-size: 16px; border-radius: 5px; border: none; background: rgba(255, 255, 255, 0.2); color: white; cursor: pointer;">Reset to Defaults</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>Audio Input</h3>
            <div class="control-row">
                <button id="micToggle" style="padding: 10px; width: 100%; font-size: 16px; border-radius: 5px; border: none; background: rgba(255, 255, 255, 0.2); color: white; cursor: pointer;">Enable Microphone</button>
            </div>
            <div class="control-row">
                <div class="control-label">Microphone</div>
                <select id="micSelect" class="audio-mapping-select" disabled>
                    <option value="">Select microphone...</option>
                </select>
            </div>
            <div class="control-row" style="align-items: flex-start;">
                <div class="control-label">Live Input</div>
                <div style="margin-left: 10px; flex-grow: 1; position: relative; height: 60px;">
                    <canvas id="audioVisualizer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.3); border-radius: 3px; border: 1px solid rgba(100, 200, 255, 0.3);"></canvas>
                    <div id="visualizerFallback" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; align-items: center; justify-content: center; color: rgba(255,255,255,0.5); font-size: 12px; text-align: center;">
                        Audio visualizer<br>will appear here
                    </div>
                </div>
            </div>
            <div class="control-row">
                <div class="control-label">Sensitivity</div>
                <input type="range" id="audioSensitivity" min="0.1" max="5" step="0.1" value="1.0">
                <div class="value-display" id="audioSensitivityValue">1.0</div>
            </div>
            <div id="audioMappings">
                <div class="control-row">
                    <div class="control-label">Bass → </div>
                    <select id="bassMapping" class="audio-mapping-select">
                        <option value="waveSpeed">Wave Speed</option>
                        <option value="wavelength" selected>Wavelength</option>
                        <option value="colorCycle">Color Cycle</option>
                        <option value="colorSpread">Color Spread</option>
                        <option value="centerSpeed">Center Speed</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="control-row">
                    <div class="control-label">Mid → </div>
                    <select id="midMapping" class="audio-mapping-select">
                        <option value="waveSpeed">Wave Speed</option>
                        <option value="wavelength">Wavelength</option>
                        <option value="colorCycle" selected>Color Cycle</option>
                        <option value="colorSpread">Color Spread</option>
                        <option value="centerSpeed">Center Speed</option>
                        <option value="none">None</option>
                    </select>
                </div>
                <div class="control-row">
                    <div class="control-label">Treble → </div>
                    <select id="trebleMapping" class="audio-mapping-select">
                        <option value="waveSpeed" selected>Wave Speed</option>
                        <option value="wavelength">Wavelength</option>
                        <option value="colorCycle">Color Cycle</option>
                        <option value="colorSpread">Color Spread</option>
                        <option value="centerSpeed">Center Speed</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
            <div id="audioLevels" class="audio-levels" style="display: flex; height: 20px; margin-top: 10px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                <div id="bassLevel" style="flex: 1; height: 100%; background: rgb(255,50,50); transform-origin: left; transform: scaleX(0);"></div>
                <div id="midLevel" style="flex: 1; height: 100%; background: rgb(50,255,50); transform-origin: left; transform: scaleX(0);"></div>
                <div id="trebleLevel" style="flex: 1; height: 100%; background: rgb(50,50,255); transform-origin: left; transform: scaleX(0);"></div>
            </div>
        </div>
    </div>
    <button id="toggleControls" style="touch-action: manipulation;">Show Controls</button>
    
    <script>
        // Get canvas and set initial resolution
        const canvas = document.getElementById('myCanvas');
        let renderWidth = 320;
        let renderHeight = 240;
        const ctx = canvas.getContext('2d');

        // Settings object with defaults
        const defaultSettings = {
            waveSpeed: 0.14,
            centerMovementSpeed: 0.047,
            variability: 0.34,
            baseWavelength: 23,
            colorCycleSpeed: 24,
            startColor: 286,
            endColor: 192,
            colorSpread: 0.6,
            resolution: 0.45,
            numCenters: 3,
            lockColorRange: true,
            showStats: true,
            audioEnabled: false,
            audioSensitivity: 1.0,
            bassMapping: 'wavelength',
            midMapping: 'colorCycle',
            trebleMapping: 'waveSpeed'
        };
        
        // Audio variables
        let audioContext;
        let analyser;
        let microphone;
        let audioDataArray;
        let timeDataArray;
        const AUDIO_FFT_SIZE = 1024;
        const BASS_RANGE = [20, 250];    // 20Hz - 250Hz
        const MID_RANGE = [250, 2000];   // 250Hz - 2kHz
        const TREBLE_RANGE = [2000, 16000]; // 2kHz - 16kHz
        let audioVisualizerCtx;
        let selectedMicId = '';
        let microphoneDevices = [];
        
        // Audio level visualization
        let bassValue = 0;
        let midValue = 0;
        let trebleValue = 0;
        let visualizerAnimationId = null;
        
        // Original values to return to when audio is disabled
        const originalValues = {};
        
        // Clone default settings for current settings
        const settings = JSON.parse(JSON.stringify(defaultSettings));
        
        const paletteSize = 256;
        let fpsTimes = [];
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        
        // Define centers - will be initialized based on numCenters
        let centers = [];
        let fixedPhaseOffsets = [];
        let fixedWavelengthVariations = [];
        
        // Initialize centers and their properties
        function initCenters() {
            centers = [];
            fixedPhaseOffsets = [];
            fixedWavelengthVariations = [];
            
            for (let i = 0; i < settings.numCenters; i++) {
                // Distribute centers around the canvas
                const angle = (i / settings.numCenters) * 2 * Math.PI;
                const radius = Math.min(renderWidth, renderHeight) * 0.3;
                const x = renderWidth / 2 + Math.cos(angle) * radius;
                const y = renderHeight / 2 + Math.sin(angle) * radius;
                
                // Random movement direction
                const speed = 0.02 + Math.random() * 0.02;
                const moveAngle = Math.random() * 2 * Math.PI;
                
                centers.push({
                    x: x,
                    y: y,
                    dx: Math.cos(moveAngle) * speed,
                    dy: Math.sin(moveAngle) * speed
                });
                
                fixedPhaseOffsets.push(Math.random() * 2 * Math.PI);
                fixedWavelengthVariations.push((Math.random() - 0.5));
            }
        }
        
        // Initialize color preview
        function updateColorPreview() {
            const container = document.getElementById('colorPreview');
            container.innerHTML = '';
            
            const startHue = settings.startColor;
            const endHue = settings.endColor;
            
            // Calculate the shortest distance between the colors on the color wheel
            let hueDiff = (endHue - startHue + 360) % 360;
            if (hueDiff > 180) hueDiff = hueDiff - 360;
            
            const numBoxes = 20;
            for (let i = 0; i < numBoxes; i++) {
                const box = document.createElement('div');
                box.className = 'color-box';
                
                // Calculate hue for this box
                const hue = (startHue + (hueDiff * (i / (numBoxes - 1))) + 360) % 360;
                box.style.backgroundColor = `hsl(${hue}, 100%, 50%)`;
                
                container.appendChild(box);
            }
        }

        // HSL to RGB conversion function
        function hslToRgb(h, s, l) {
            h = h % 360;
            s = Math.min(1, Math.max(0, s));
            l = Math.min(1, Math.max(0, l));
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        // Generate color palette with range between startColor and endColor
        function generatePalette(offset = 0) {
            const palette = new Uint8ClampedArray(paletteSize * 4);
            const startHue = settings.startColor;
            let endHue = settings.endColor;
            
            // Calculate the shortest distance between the colors on the color wheel
            let hueDiff = (endHue - startHue + 360) % 360;
            if (hueDiff > 180) hueDiff = hueDiff - 360;
            
            for (let i = 0; i < paletteSize; i++) {
                // Normalized position in the palette
                const t = i / (paletteSize - 1);
                
                // Apply offset for animation if color range isn't locked
                let huePosition;
                if (settings.lockColorRange) {
                    // Static color range - just interpolate between start and end
                    huePosition = t;
                } else {
                    // Animated color range - shift the position but keep within range
                    huePosition = (t + offset) % 1;
                }
                
                // Calculate the final hue
                const hue = (startHue + hueDiff * huePosition + 360) % 360;
                
                // Convert to RGB and store in palette
                const [r, g, b] = hslToRgb(hue, 1, 0.5);
                palette[i * 4] = r;
                palette[i * 4 + 1] = g;
                palette[i * 4 + 2] = b;
                palette[i * 4 + 3] = 255;
            }
            return palette;
        }

        // Update center positions
        function updateCenters() {
            centers.forEach(center => {
                center.x += center.dx * settings.centerMovementSpeed * renderWidth;
                center.y += center.dy * settings.centerMovementSpeed * renderHeight;
                if (center.x < 0 || center.x > renderWidth) center.dx *= -1;
                if (center.y < 0 || center.y > renderHeight) center.dy *= -1;
            });
        }
        
        // Calculate FPS
        function updateFPS(now) {
            const elapsed = now - lastFrameTime;
            lastFrameTime = now;
            
            fpsTimes.push(elapsed);
            if (fpsTimes.length > 60) {
                fpsTimes.shift();
            }
            
            frameCount++;
            if (frameCount >= 10) {
                const sum = fpsTimes.reduce((a, b) => a + b, 0);
                const avg = sum / fpsTimes.length;
                fps = Math.round(1000 / avg);
                frameCount = 0;
            }
        }
        
        // Render stats overlay
        function renderStats() {
            const statsDiv = document.getElementById('stats');
            if (settings.showStats) {
                statsDiv.style.display = 'block';
                let audioStatus = '';
                
                if (settings.audioEnabled) {
                    // Get current microphone label - using actual tracked device
                    let micLabel = "Default Microphone";
                    
                    // First try getting the label from the select element (most reliable)
                    const micSelect = document.getElementById('micSelect');
                    if (micSelect && micSelect.selectedIndex > 0) {
                        const selectedOption = micSelect.options[micSelect.selectedIndex];
                        micLabel = selectedOption.textContent;
                    } 
                    // Fallback: search through device list
                    else {
                        const selectedMic = microphoneDevices.find(device => device.deviceId === selectedMicId);
                        if (selectedMic && selectedMic.label) {
                            micLabel = selectedMic.label;
                        }
                    }
                    
                    // Format to get a concise label
                    if (micLabel.includes('(')) {
                        const parts = micLabel.split('(');
                        // For Mac we often want the part in parentheses which shows if it's built-in, etc.
                        const part1 = parts[0].trim();
                        const part2 = parts[1].replace(')', '').trim();
                        
                        // Use the more informative part or combine them
                        if (part1.toLowerCase().includes('default') || part1.length < 3) {
                            micLabel = part2;
                        } else if (part2.toLowerCase().includes('built-in')) {
                            micLabel = `${part1} (Built-in)`;
                        } else {
                            micLabel = part1;
                        }
                    }
                    
                    // Final truncation if needed
                    if (micLabel.length > 25) {
                        micLabel = micLabel.substring(0, 22) + '...';
                    }
                    
                    audioStatus = `<br>Audio: ON [${micLabel}]<br>Levels: B:${bassValue.toFixed(2)}, M:${midValue.toFixed(2)}, T:${trebleValue.toFixed(2)}`;
                }
                
                statsDiv.innerHTML = `
                    FPS: ${fps}<br>
                    Resolution: ${renderWidth}x${renderHeight}<br>
                    Centers: ${centers.length}${audioStatus}
                `;
            } else {
                statsDiv.style.display = 'none';
            }
        }
        
        // Force device enumeration with full labels
        async function forceDeviceEnumeration() {
            try {
                // We need to get actual access to the microphone to get the full device labels
                console.log("Requesting temporary microphone access to get device labels...");
                const tempStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Now that we have permission, enumerate devices - this should give us full labels
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                // Log all found devices to console to help debug
                console.log("All devices found:", devices);
                
                // We don't need to keep this stream, just needed for permission
                tempStream.getTracks().forEach(track => {
                    console.log(`Stopping temporary track: ${track.kind} - ${track.label}`);
                    track.stop();
                });
                
                return devices.filter(device => device.kind === 'audioinput');
            } catch (error) {
                console.error('Error enumerating devices with full labels:', error);
                return [];
            }
        }
        
        // Enumerate available audio devices
        async function enumerateAudioDevices() {
            try {
                // Force enumeration with permissions to get full device labels
                microphoneDevices = await forceDeviceEnumeration();
                
                if (microphoneDevices.length === 0) {
                    console.warn("No microphone devices found or permission denied");
                    return [];
                }
                
                // Populate the dropdown
                const select = document.getElementById('micSelect');
                select.innerHTML = '<option value="">Select microphone...</option>';
                
                // Log which devices we found
                console.log('Available microphones:', microphoneDevices.map(d => d.label || 'Unnamed device'));
                
                // Add each device to the dropdown
                microphoneDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    
                    // Get proper label for the device
                    // Starting with default if no label is available
                    let label = device.label;
                    if (!label || label.trim() === '') {
                        label = `Microphone ${index + 1}`;
                    }
                    
                    // For macOS, which often has format: "Device Name (Type)"
                    if (label.includes('(')) {
                        option.setAttribute('data-full-name', label);
                    }
                    
                    // Keep labels reasonably sized
                    if (label.length > 30) {
                        label = label.substring(0, 27) + '...';
                    }
                    
                    option.textContent = label;
                    select.appendChild(option);
                });
                
                // Enable the select if we have microphones
                select.disabled = microphoneDevices.length === 0;
                
                // If we have devices but no selection, select the first one
                if (microphoneDevices.length > 0 && !selectedMicId) {
                    selectedMicId = microphoneDevices[0].deviceId;
                    select.value = selectedMicId;
                }
                
                return microphoneDevices;
            } catch (error) {
                console.error('Error enumerating devices:', error);
                return [];
            }
        }
        
        // Initialize the audio visualizer with DOM fallback
        function initAudioVisualizer() {
            // Show fallback message initially
            document.getElementById('visualizerFallback').style.display = 'flex';
            
            const canvas = document.getElementById('audioVisualizer');
            
            try {
                // Create canvas context
                audioVisualizerCtx = canvas.getContext('2d', { 
                    alpha: false,  // Optimization for performance
                    desynchronized: true // Potential performance boost
                });
                
                // Get parent container dimensions
                const container = canvas.parentElement;
                const rect = container.getBoundingClientRect();
                
                // Log for debugging
                console.log("Visualizer container size:", rect.width, "x", rect.height);
                
                // Set canvas dimensions to match container (crucial step)
                canvas.width = Math.max(rect.width, 100);
                canvas.height = Math.max(rect.height, 50);
                
                console.log("Canvas size set to:", canvas.width, "x", canvas.height);
                
                // Draw initial state - black background
                audioVisualizerCtx.fillStyle = '#000000';
                audioVisualizerCtx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Initialize with empty bars
                const barCount = 10;
                const barWidth = Math.floor((canvas.width - (barCount+1)) / barCount);
                
                audioVisualizerCtx.fillStyle = 'rgba(100, 200, 255, 0.2)';
                
                for (let i = 0; i < barCount; i++) {
                    const barX = i * (barWidth + 1) + 1;
                    audioVisualizerCtx.fillRect(barX, canvas.height - 5, barWidth, 5);
                }
                
                // Hide fallback message now that canvas is working
                document.getElementById('visualizerFallback').style.display = 'none';
                
                return true;
            } catch (error) {
                console.error("Error initializing canvas:", error);
                // Keep fallback message displayed
                document.getElementById('visualizerFallback').style.display = 'flex';
                return false;
            }
        }
        
        // Completely simplified visualizer using DOM elements as backup approach
        function drawAudioVisualizer() {
            if (!settings.audioEnabled || !analyser) {
                return;
            }
            
            try {
                // Get frequency data (works better than time data for simple visualization)
                if (!audioDataArray) {
                    audioDataArray = new Uint8Array(analyser.frequencyBinCount);
                }
                
                analyser.getByteFrequencyData(audioDataArray);
                
                // Get canvas and dimensions
                const canvas = document.getElementById('audioVisualizer');
                const width = canvas.width;
                const height = canvas.height;
                
                if (!audioVisualizerCtx) {
                    // Try to recreate context if it was lost
                    audioVisualizerCtx = canvas.getContext('2d');
                    if (!audioVisualizerCtx) {
                        throw new Error("Could not get canvas context");
                    }
                }
                
                // Clear canvas
                audioVisualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                audioVisualizerCtx.fillRect(0, 0, width, height);
                
                // Simplified bar visualization with fewer bars
                const barCount = 10; // Fewer, more visible bars
                const barWidth = Math.floor((width - (barCount+1)) / barCount);
                const barSpacing = 1;
                
                // Use frequency data for nice visualization
                // Divide frequency data into ranges
                const totalBins = audioDataArray.length;
                const binsPerBar = Math.floor(totalBins / barCount);
                
                for (let i = 0; i < barCount; i++) {
                    // Get average value for this frequency range
                    let sum = 0;
                    const startBin = i * binsPerBar;
                    const endBin = Math.min(startBin + binsPerBar, totalBins);
                    
                    for (let j = startBin; j < endBin; j++) {
                        sum += audioDataArray[j];
                    }
                    
                    // Calculate average (0-255)
                    const average = sum / binsPerBar;
                    
                    // Scale to height (leaves a small margin)
                    const barHeight = Math.max(2, (average / 255) * (height - 4));
                    
                    // Calculate color based on frequency (blue to cyan to green)
                    const hue = 180 + (i / barCount) * 60; // 180-240 range (cyan-blue)
                    audioVisualizerCtx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    
                    // Draw bar from bottom
                    const barX = i * (barWidth + barSpacing) + barSpacing;
                    const barY = height - barHeight;
                    
                    audioVisualizerCtx.fillRect(barX, barY, barWidth, barHeight);
                }
                
                // Hide fallback when visualization is working
                document.getElementById('visualizerFallback').style.display = 'none';
                
                // Schedule next frame
                visualizerAnimationId = requestAnimationFrame(drawAudioVisualizer);
                
            } catch (error) {
                console.error("Error in audio visualizer:", error);
                
                // Show fallback message since visualization failed
                document.getElementById('visualizerFallback').style.display = 'flex';
                
                // Still continue animation in case it can recover
                visualizerAnimationId = requestAnimationFrame(drawAudioVisualizer);
            }
        }
                
        // Setup audio processing
        async function setupAudio() {
            try {
                // Store original values before audio takes over
                saveOriginalValues();
                
                // Create audio context if it doesn't exist
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Enumerate available audio devices (this will show proper labels)
                await enumerateAudioDevices();
                
                console.log(`Using microphone with ID: ${selectedMicId}`);
                
                // Get microphone access with selected device if available
                const constraints = { 
                    audio: selectedMicId ? { deviceId: { exact: selectedMicId } } : true,
                    video: false 
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Create audio analyser
                analyser = audioContext.createAnalyser();
                analyser.fftSize = AUDIO_FFT_SIZE;
                analyser.smoothingTimeConstant = 0.85;
                
                // Connect microphone to analyser
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                // Create data arrays for analysis
                audioDataArray = new Uint8Array(analyser.frequencyBinCount);
                timeDataArray = new Uint8Array(analyser.frequencyBinCount);
                
                // Initialize and start the audio visualizer
                initAudioVisualizer();
                
                // Only start a new animation frame if one isn't already running
                if (!visualizerAnimationId) {
                    drawAudioVisualizer();
                }
                
                // Enable audio in settings
                settings.audioEnabled = true;
                
                // Enable the microphone selection dropdown
                document.getElementById('micSelect').disabled = false;
                
                // Update the UI
                document.getElementById('micToggle').textContent = 'Disable Microphone';
                document.getElementById('micToggle').style.background = 'rgba(255, 100, 100, 0.4)';
                
                // Make sure the current microphone is selected in the dropdown
                const micSelect = document.getElementById('micSelect');
                if (selectedMicId && micSelect.value !== selectedMicId) {
                    micSelect.value = selectedMicId;
                }
                
                console.log('Audio setup complete');
            } catch (error) {
                console.error('Error setting up audio:', error);
                alert('Could not access microphone. Please check permissions.');
                
                settings.audioEnabled = false;
                document.getElementById('micToggle').textContent = 'Enable Microphone';
                document.getElementById('micToggle').style.background = 'rgba(255, 255, 255, 0.2)';
            }
        }
        
        // Stop audio processing
        function stopAudio() {
            if (microphone && audioContext) {
                microphone.disconnect();
                
                // Some browsers may not support close()
                if (audioContext.state !== 'closed' && audioContext.close) {
                    audioContext.close();
                }
                
                // Stop visualizer animation
                if (visualizerAnimationId) {
                    cancelAnimationFrame(visualizerAnimationId);
                    visualizerAnimationId = null;
                }
                
                // Clear visualizer
                if (audioVisualizerCtx) {
                    const canvas = document.getElementById('audioVisualizer');
                    audioVisualizerCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    audioVisualizerCtx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // Restore original values
                restoreOriginalValues();
                
                microphone = null;
                analyser = null;
                audioContext = null;
                settings.audioEnabled = false;
                
                // Update the UI
                document.getElementById('micToggle').textContent = 'Enable Microphone';
                document.getElementById('micToggle').style.background = 'rgba(255, 255, 255, 0.2)';
                document.getElementById('micSelect').disabled = true;
                
                // Reset audio level indicators
                document.getElementById('bassLevel').style.transform = 'scaleX(0)';
                document.getElementById('midLevel').style.transform = 'scaleX(0)';
                document.getElementById('trebleLevel').style.transform = 'scaleX(0)';
                
                bassValue = 0;
                midValue = 0;
                trebleValue = 0;
                
                console.log('Audio stopped');
            }
        }
        
        // Save original values before audio modulation
        function saveOriginalValues() {
            originalValues.waveSpeed = settings.waveSpeed;
            originalValues.baseWavelength = settings.baseWavelength;
            originalValues.colorCycleSpeed = settings.colorCycleSpeed;
            originalValues.colorSpread = settings.colorSpread;
            originalValues.centerMovementSpeed = settings.centerMovementSpeed;
        }
        
        // Restore original values when audio is disabled
        function restoreOriginalValues() {
            settings.waveSpeed = originalValues.waveSpeed;
            settings.baseWavelength = originalValues.baseWavelength;
            settings.colorCycleSpeed = originalValues.colorCycleSpeed;
            settings.colorSpread = originalValues.colorSpread;
            settings.centerMovementSpeed = originalValues.centerMovementSpeed;
            
            // Update UI sliders
            document.getElementById('waveSpeed').value = settings.waveSpeed;
            document.getElementById('waveSpeedValue').textContent = settings.waveSpeed;
            
            document.getElementById('baseWavelength').value = settings.baseWavelength;
            document.getElementById('baseWavelengthValue').textContent = settings.baseWavelength;
            
            document.getElementById('colorCycleSpeed').value = settings.colorCycleSpeed;
            document.getElementById('colorCycleSpeedValue').textContent = settings.colorCycleSpeed;
            
            document.getElementById('colorSpread').value = settings.colorSpread;
            document.getElementById('colorSpreadValue').textContent = settings.colorSpread;
            
            document.getElementById('centerMovementSpeed').value = settings.centerMovementSpeed;
            document.getElementById('centerMovementSpeedValue').textContent = settings.centerMovementSpeed;
        }
        
        // Process audio data and update visualization parameters
        function processAudio() {
            if (!settings.audioEnabled || !analyser) return;
            
            // Get frequency data
            analyser.getByteFrequencyData(audioDataArray);
            
            // Get frequency ranges
            const frequencyResolution = audioContext.sampleRate / AUDIO_FFT_SIZE;
            
            // Calculate indices for different frequency ranges
            const bassStart = Math.floor(BASS_RANGE[0] / frequencyResolution);
            const bassEnd = Math.floor(BASS_RANGE[1] / frequencyResolution);
            
            const midStart = Math.floor(MID_RANGE[0] / frequencyResolution);
            const midEnd = Math.floor(MID_RANGE[1] / frequencyResolution);
            
            const trebleStart = Math.floor(TREBLE_RANGE[0] / frequencyResolution);
            const trebleEnd = Math.min(Math.floor(TREBLE_RANGE[1] / frequencyResolution), audioDataArray.length - 1);
            
            // Calculate average levels for each range
            let bassSum = 0;
            for (let i = bassStart; i < bassEnd; i++) {
                bassSum += audioDataArray[i];
            }
            
            let midSum = 0;
            for (let i = midStart; i < midEnd; i++) {
                midSum += audioDataArray[i];
            }
            
            let trebleSum = 0;
            for (let i = trebleStart; i < trebleEnd; i++) {
                trebleSum += audioDataArray[i];
            }
            
            // Normalize to 0-1 range
            bassValue = (bassSum / (bassEnd - bassStart)) / 255;
            midValue = (midSum / (midEnd - midStart)) / 255;
            trebleValue = (trebleSum / (trebleEnd - trebleStart)) / 255;
            
            // Apply sensitivity
            const sensitivity = settings.audioSensitivity;
            bassValue = Math.min(1, bassValue * sensitivity);
            midValue = Math.min(1, midValue * sensitivity);
            trebleValue = Math.min(1, trebleValue * sensitivity);
            
            // Update visualizer bars
            document.getElementById('bassLevel').style.transform = `scaleX(${bassValue})`;
            document.getElementById('midLevel').style.transform = `scaleX(${midValue})`;
            document.getElementById('trebleLevel').style.transform = `scaleX(${trebleValue})`;
            
            // Apply mappings to settings
            applyAudioMapping(settings.bassMapping, bassValue);
            applyAudioMapping(settings.midMapping, midValue);
            applyAudioMapping(settings.trebleMapping, trebleValue);
        }
        
        // Apply audio value to the mapped parameter
        function applyAudioMapping(mapping, value) {
            switch (mapping) {
                case 'waveSpeed':
                    settings.waveSpeed = originalValues.waveSpeed * (1 + value * 3);
                    break;
                case 'wavelength':
                    settings.baseWavelength = originalValues.baseWavelength * (1 + value * 5);
                    break;
                case 'colorCycle':
                    settings.colorCycleSpeed = originalValues.colorCycleSpeed * (1 + value * 5);
                    break;
                case 'colorSpread':
                    settings.colorSpread = originalValues.colorSpread * (1 + value * 3);
                    break;
                case 'centerSpeed':
                    settings.centerMovementSpeed = originalValues.centerMovementSpeed * (1 + value * 5);
                    break;
                case 'none':
                    // Do nothing
                    break;
            }
        }
        
        // Resize handler
        function handleResize() {
            // Update the physical canvas size to match the display size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Set the rendering resolution based on the settings
            renderWidth = Math.floor(window.innerWidth * settings.resolution);
            renderHeight = Math.floor(window.innerHeight * settings.resolution);
        }

        // Animation loop
        function animate(time) {
            time = time * 0.001; // Convert to seconds
            updateFPS(time * 1000);
            updateCenters();
            
            // Process audio if enabled
            if (settings.audioEnabled) {
                processAudio();
            }
            
            // Calculate color cycle offset
            const offset = (time * settings.colorCycleSpeed / 100) % 1;
            const palette = generatePalette(offset);

            // Calculate dynamic wavelengths and phase offsets
            const phaseOffsets = fixedPhaseOffsets.map(offset => offset * settings.variability);
            const wavelengths = fixedWavelengthVariations.map(variation => 
                settings.baseWavelength * (1 + variation * settings.variability)
            );

            // Create a smaller imageData for rendering
            const imageData = ctx.createImageData(renderWidth, renderHeight);
            const data = imageData.data;
            
            // Render the wave interference
            for (let y = 0; y < renderHeight; y++) {
                for (let x = 0; x < renderWidth; x++) {
                    let wave = 0;
                    for (let i = 0; i < centers.length; i++) {
                        const dx = x - centers[i].x;
                        const dy = y - centers[i].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        wave += Math.sin(2 * Math.PI * (distance / wavelengths[i] - settings.waveSpeed * time) + phaseOffsets[i]);
                    }
                    wave /= centers.length; // Normalize
                    const normalizedWave = (wave + 1) / 2;
                    const adjustedWave = Math.pow(normalizedWave, settings.colorSpread);
                    const paletteIndex = Math.floor(adjustedWave * (paletteSize - 1));
                    const idx = (y * renderWidth + x) * 4;
                    data[idx] = palette[paletteIndex * 4];
                    data[idx + 1] = palette[paletteIndex * 4 + 1];
                    data[idx + 2] = palette[paletteIndex * 4 + 2];
                    data[idx + 3] = 255;
                }
            }
            
            // Scale the rendered image to fill the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = renderWidth;
            tempCanvas.height = renderHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            // Use CSS scaling for better quality
            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            
            // Render stats if enabled
            renderStats();
            
            requestAnimationFrame(animate);
        }

        // Set up event listeners
        document.getElementById('waveSpeed').addEventListener('input', function() {
            settings.waveSpeed = parseFloat(this.value);
            document.getElementById('waveSpeedValue').textContent = this.value;
        });
        
        document.getElementById('centerMovementSpeed').addEventListener('input', function() {
            settings.centerMovementSpeed = parseFloat(this.value);
            document.getElementById('centerMovementSpeedValue').textContent = this.value;
        });
        
        document.getElementById('variability').addEventListener('input', function() {
            settings.variability = parseFloat(this.value);
            document.getElementById('variabilityValue').textContent = this.value;
        });
        
        document.getElementById('baseWavelength').addEventListener('input', function() {
            settings.baseWavelength = parseFloat(this.value);
            document.getElementById('baseWavelengthValue').textContent = this.value;
        });
        
        document.getElementById('startColor').addEventListener('input', function() {
            settings.startColor = parseFloat(this.value);
            document.getElementById('startColorValue').textContent = this.value;
            updateColorPreview();
        });
        
        document.getElementById('endColor').addEventListener('input', function() {
            settings.endColor = parseFloat(this.value);
            document.getElementById('endColorValue').textContent = this.value;
            updateColorPreview();
        });
        
        document.getElementById('colorCycleSpeed').addEventListener('input', function() {
            settings.colorCycleSpeed = parseFloat(this.value);
            document.getElementById('colorCycleSpeedValue').textContent = this.value;
        });
        
        document.getElementById('colorSpread').addEventListener('input', function() {
            settings.colorSpread = parseFloat(this.value);
            document.getElementById('colorSpreadValue').textContent = this.value;
        });
        
        document.getElementById('resolution').addEventListener('input', function() {
            settings.resolution = parseFloat(this.value);
            document.getElementById('resolutionValue').textContent = this.value + 'x';
            handleResize();
        });
        
        document.getElementById('numCenters').addEventListener('input', function() {
            settings.numCenters = parseInt(this.value);
            document.getElementById('numCentersValue').textContent = this.value;
            initCenters();
        });
        
        document.getElementById('lockColorRange').addEventListener('change', function() {
            settings.lockColorRange = this.checked;
        });
        
        document.getElementById('showStats').addEventListener('change', function() {
            settings.showStats = this.checked;
        });
        
        document.getElementById('resetBtn').addEventListener('click', function() {
            // Reset all settings to defaults
            Object.assign(settings, defaultSettings);
            
            // Update all UI elements
            const controls = document.querySelectorAll('input[type="range"], input[type="checkbox"]');
            controls.forEach(control => {
                if (control.type === 'range') {
                    control.value = settings[control.id];
                    document.getElementById(control.id + 'Value').textContent = 
                        control.id === 'resolution' ? settings[control.id] + 'x' : settings[control.id];
                } else if (control.type === 'checkbox') {
                    control.checked = settings[control.id];
                }
            });
            
            // Reinitialize centers and resize
            initCenters();
            handleResize();
            updateColorPreview();
        });
        
        // Toggle controls visibility
        document.getElementById('toggleControls').addEventListener('click', function() {
            const controls = document.getElementById('controls');
            if (controls.style.display === 'none') {
                controls.style.display = 'flex';
                this.textContent = 'Hide Controls';
            } else {
                controls.style.display = 'none';
                this.textContent = 'Show Controls';
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', handleResize);
        
        // Audio controls
        document.getElementById('micToggle').addEventListener('click', function() {
            if (settings.audioEnabled) {
                stopAudio();
            } else {
                setupAudio();
            }
        });
        
        document.getElementById('micSelect').addEventListener('change', function() {
            if (this.value) {
                selectedMicId = this.value;
                
                // If audio is already enabled, restart with new microphone
                if (settings.audioEnabled) {
                    stopAudio();
                    setTimeout(() => setupAudio(), 300); // Small delay to ensure cleanup
                }
            }
        });
        
        document.getElementById('audioSensitivity').addEventListener('input', function() {
            settings.audioSensitivity = parseFloat(this.value);
            document.getElementById('audioSensitivityValue').textContent = this.value;
        });
        
        document.getElementById('bassMapping').addEventListener('change', function() {
            settings.bassMapping = this.value;
        });
        
        document.getElementById('midMapping').addEventListener('change', function() {
            settings.midMapping = this.value;
        });
        
        document.getElementById('trebleMapping').addEventListener('change', function() {
            settings.trebleMapping = this.value;
        });
        
        // Initialize
        handleResize();
        initCenters();
        updateColorPreview();
        
        // Initialize stats display
        renderStats();
        
        // Start the animation
        requestAnimationFrame(animate);
    </script>
</body>
</html>